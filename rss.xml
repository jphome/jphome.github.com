<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>小蒋</title>
    <link>http://jphome.github.com</link>
    <pubDate>01 Aug 14 22:17 CST</pubDate>
    <item>
      <title>Raspberry Pi烧写Openwrt固件</title>
      <link>http://jphome.github.com/blog/2014/08/01/raspberry_pi_openwrt.html</link>
      <pubDate>2014-08-01 09:55:26 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;给树莓派做上Openwrt固件学习luci编程&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参考: &lt;a href=&#34;http://show.smzdm.com/detail/41689&#34;&gt;http://show.smzdm.com/detail/41689&lt;/a&gt;&#xA;&lt;hr/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;1.下载Openwrt固件、启动补丁文件&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;固件：openwrt-brcm2708-sdcard-vfat-ext4_224.img&#xA;http://downloads.openwrt.org/attitude_adjustment/12.09/brcm2708/generic/&#xA;启动补丁：使用OPENWRT的正确姿势.zip&#xA;http://pan.baidu.com/share/link?shareid=496011089&amp;amp;uk=1328231555&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;2.烧写固件&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;插上SD卡&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo umount /dev/sdbn           ###&amp;lt; 卸载/dev/sdb的所有分区&#xA;sudo fdisk /dev/sdb             ###&amp;lt; 删除/dev/sdb的所有分区&#xA;sudo dd bs=1M if=openwrt-brcm2708-sdcard-vfat-ext4_224.img of=/dev/sdb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;完成后使用补丁文件bootcode.bin、start.elf替换SD卡FAT分区的启动文件&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>sed</title>
      <link>http://jphome.github.com/blog/2014/06/15/readme_sed.html</link>
      <pubDate>2014-06-15 01:14:48 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;摘录sed工具的使用&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;url:&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;http://blog.csdn.net/a81895898/article/details/8482387&#xA;http://coolshell.cn/articles/9104.html&#xA;http://tsnc.zhongaokao.com/tsnc_wgrj/doc/sed.htm&#xA;http://kodango.com/sed1line-notes&#xA;&lt;/pre&gt;&#xA;    &#xA;&#xA;&lt;h3&gt;sed调试工具&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sedsed&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;正则：&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;h4&gt;规则&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;^       表示一行的开头&#xA;$       表示一行的结尾&#xA;\&lt;      表示词首。如\&lt;abc表示以abc为首的词&#xA;\&gt;      表示词尾。如\&gt;abc表示以abc为尾的词&#xA;.       表示任意单个字符&#xA;*       表示某个字符出现了0次或多次&#xA;+       表示某个字符出现了1次或多次&#xA;[abc]   表示a或b或c字符&#xA;[^c]    表示非c的字符&#xA;&amp;       表示被匹配的变量&#xA;\num    被匹配的第num个分组（\(...\)括起来的部分成为分组）&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;e.g.&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;/[012]\{3\}/                                ###&lt; 三个数字 [012]{3}&#xA;sed &#39;s/xxx/[&amp;]/g&#39; my.txt                    ###&lt; 匹配项加[]&#xA;s/(ACTIVE_CONSOLES=/dev/tty\[1-)6]/\12]/    ###&lt; ACTIVE_CONSOLES=/dev/tty[1-6]&#xA;                                            ###&lt; -&gt; ACTIVE_CONSOLES=/dev/tty[1-2]&#xA;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;工作形式&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;sed [option] script file&#xA;script是由一条或多条指令(instruction)构成&#xA;指令由正则表达式(pattern)和编辑命令(action)构成&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;工作过程&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;以行为单位处理&#xA;每一行都是被读入到一块缓存空间，该空间名为模式空间(pattern space)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;sed选项&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;h4&gt;-e：选项可选，在命令行中同时指定多个操作指令时用到&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;sed -e &#39;s/x/y/&#39; -e &#39;s/y/x/&#39; file&#xA;sed &#39;s/x/y/;s/y/x/&#39; file&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;-n：抑制默认输出（sed默认会把处理过的内容全输出）&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;sed &#39;s/x/y/p&#39; file          默认输出全部内容，等于把匹配的行输出两遍&#xA;sed -n &#39;s/x/y/p&#39; file       只打印匹配的行&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;-i：对文件进行修改&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;默认不修改文件，输出到stdout&#xA;作用类似 sed &#34;s/my/jphome&#39;s/g&#34; pets.txt &gt; pets.txt&#xA;sed &#34;s/my/jphome&#39;s/g&#34; pets.txt          ###&lt; 输出文件到stdout，没有对文件进行修改&#xA;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;sed打印命令&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;# p：打印匹配行 （类似于grep）&#xA;sed &#39;/fish/p&#39; my.txt        /// 会输出所有&#xA;sed -n &#39;fish/p&#39; my.txt      /// 只打印匹配行&#xA;&#xA;# =：打印行号&#xA;sed &#39;/fish/=&#39; my.txt&#xA;&#xA;# l：打印行，打印在模式空间中的行，同时显示控制字符&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;sed转换命令&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;# [address]y/SET1/SET2/&#xA;echo &#34;hello world&#34; | sed &#39;y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/&#39;     ###&lt; -&gt; HELLO WORLD&#xA;sed &#39;y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/&#39; file&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;sed编辑命令&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;# i：前面插入&#xA;# a：后面添加&#xA;# c：替换行&#xA;sed &#39;1 i Insert&#39; my.txt             ###&lt; 在第一行前插入一行xxx&#xA;sed &#39;$ a Append&#39; my.txt             ###&lt; 在最后一行后添加一行xxx&#xA;sed &#39;/fish/a Append fish&#39; my.txt    ###&lt; 在匹配到fish的那行后面插入一行xxx&#xA;sed &#39;2 c This is monkey&#39;            ###&lt; 替换第二行为xxx&#xA;sed &#34;/fish/c this is monkey&#34;        ###&lt; 替换匹配到fish的行&#xA;/fish/c\                            ###&lt; 支持多行&#xA;xxx\                                ###&lt; sed -i -f xxx.sed xxx.txt&#xA;xxx&#xA;&#xA;# d：删除行&#xA;sed &#39;/fish/d&#39; my.txt        /// 删除匹配到fish的一行&#xA;sed &#39;2d&#39; my.txt         /// 删除第二行&#xA;sed &#39;2,$d&#39; my.txt       /// 删除第二到最后一行&#xA;&#xA;# s：匹配替换(s/xx/xx/)&#xA;单引号内无法使用转义符/&#xA;# 只替换每一行的第一个xx&#xA;sed &#39;s/xx/xx/1&#39;&#xA;# 只替换每一行的第二个xx&#xA;sed &#39;s/xx/xx/2&#xA;# 只替换每一行的第三个以后的xx&#xA;sed &#39;s/xx/xx/3g&#39;&#xA;# 替换每一行的所有匹配&#xA;sed &#39;s/xx/XX/g&#39;&#xA;&#xA;# r: 将文件内容读入匹配行后面&#xA;# sed会把r后面的任何字符判断为文件名,直到回车或单引号，所以不能用;来连接其他语句&#xA;sed &#39;/pattern/r file1&#39; file                     ###&lt; 将file1文件的内容添加到匹配行后面&#xA;sed &#39;/pattern/{r file1&#39; -e other cmd} file&#xA;sed &#39;/pattern/{r file1&#xA;other cmd&#xA;}&#39; file&#xA;&#xA;# w: 将匹配到的内容写到文件&#xA;sed &#39;/pattern/w file1&#39; file&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;保持空间&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;# 小写覆盖、大写追加（追加内容与原内容以\n分隔）&#xA;h/H     将模式空间的内容复制/者追加到保持空间&#xA;g/G     将保持空间的内容复制/者追加到模式空间&#xA;x       交换模式空间和保持空间的内容&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;其他&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;h4&gt;!&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;表示后面的命令对所有没有被选定的行发生作用&#xA;/pattern/!{}&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;把12，34，56&amp;hellip;行当成同一行来匹配&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;sed &#39;N;s/\n//&#39; my.txt       ###&lt; 就是把12，34，56...合并成一行&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;修改指定行&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;sed &#39;3s/xx/xx/g&#39; pets.txt               ###&lt; 第3行&#xA;sed &#39;3,6s/xx/xx/g&#39; pets.txt             ###&lt; 第3～6行&#xA;sed &#39;1,${/this/d;s/^ *//g}&#39; pets.txt&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;在sed语句内使用变量&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;sed -i &#39;s/^xxx/xx=`$DIR`/&#39; xxx.file&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;条件正则&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;sed &#39;/^#define/{s/ //g}&#39;&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;n: 读取下一个输入行,用下一个命令处理新的行&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;/.H1/{n;/^$/d}      ###&lt; 删除.H1之后的第一个空行&#xA;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;例子&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;# 去除html文件中的tags&#xA;sed &#39;s/&lt;[^&gt;]*&gt;//g&#39; index.html &gt; index.html&#xA;# 行首加#&#xA;sed &#39;s/^/#/g&#39; pets.txt&#xA;# 行尾加 ---&#xA;sed &#39;s/$/ ---/g&#39; pets.txt&#xA;# 使用逗号,拼接行&#xA;sed &#39;H;$!d;${x;s/^\n//;s/\n/,/g}&#39; file&#xA;&#xA;# 命令打包&#xA;sed &#39;4,6 {/This/{/fish/d}}&#39; pets.txt&#xA;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>安装使用slickedit</title>
      <link>http://jphome.github.com/blog/2014/04/13/readme_slickedit.html</link>
      <pubDate>2014-04-13 10:06:37 +0800</pubDate>
      <description>&lt;h3&gt;类似&lt;code&gt;SourceInsight&lt;/code&gt;编辑器,尝个鲜&lt;/h3&gt;&#xA;&#xA;&lt;hr/&gt;&#xA;&#xA;&lt;h4&gt;官网下载v18.0.1版本&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;wget http://www.slickedit.com/assets/trial/se_18000102_linux32.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;安装&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;    tar xvf se_18000102_linux32.tar.gz&#xA;    cd se_18000102_linux32 &#xA;    sudo ./vsinst&#xA;    安装到/opt/slickedit路径下&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;破解 &lt;a href=&#34;http://blog.book41.net/?p=751&#34;&gt;REF&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;    cd /opt/slickedit/bin&#xA;    sudo cp vs_exe vs_exe.bak       ###&lt; 备份&#xA;    sudo chmod 775 vs_exe           ###&lt; 加w权限&#xA;    sudo vim vs_exe -b              ###&lt; 编辑二进制,不加换行符&#xA;    :%!xxd                          ###&lt; 进入十六进制编辑模式&#xA;    /009D370                        ###&lt; 搜索地址&#xA;    修改5个字节                     ###&lt; 具体见下图&#xA;    :%!xxd -r                       ###&lt; 转回二进制&#xA;    :wq                             ###&lt; 保存退出&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/img/img_readme_slickedit_0.png&#34; alt=&#34;from&#34; /&gt;&#xA;&#xA;&lt;br/&gt;&#xA;&lt;br/&gt;&#xA;&lt;img src=&#34;/assets/media/img/img_readme_slickedit_1.png&#34; alt=&#34;to&#34; /&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux 下查看局域网内所有主机IP和MAC</title>
      <link>http://jphome.github.com/blog/2014/03/29/readme_nmap.html</link>
      <pubDate>2014-03-29 11:03:54 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;用nmap对局域网扫描一遍，然后查看arp缓存表就可以知道局域内ip对应的mac了。nmap比较强大也可以直接扫描mac地址和端口。执行扫描之后就可以 cat /proc/net/arp查看arp缓存表了。&#xA;&lt;br/&gt;&#xA;&lt;br/&gt;&#xA;转自&lt;a href=&#34;http://blog.chinaunix.net/uid-25885064-id-3483813.html&#34;&gt;残剑&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr/&gt;&#xA;&#xA;&lt;h4&gt;进行ping扫描，打印出对扫描做出响应的主机：&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;$ nmap -sP 192.168.1.0/24&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;仅列出指定网络上的每台主机，不发送任何报文到目标主机：　&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;$ nmap -sL 192.168.1.0/24&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;探测目标主机开放的端口，可以指定一个以逗号分隔的端口列表(如-PS 22，23，25，80)：&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;$ nmap -PS 192.168.1.234&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;使用UDP ping探测主机：&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;$ nmap -PU 192.168.1.0/24&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;使用频率最高的扫描选项（SYN扫描,又称为半开放扫描），它不打开一个完全的TCP连接，执行得很快：&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;$ nmap -sS 192.168.1.0/24&#xA;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>用u盘扩展openwrt路由器存储</title>
      <link>http://jphome.github.com/blog/2014/03/29/readme_opkg.html</link>
      <pubDate>2014-03-29 09:36:20 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;由于flash太小,可以用&lt;code&gt;读卡器+sd卡/U盘/移动硬盘&lt;/code&gt;来扩展路由器的存储&#xA;&lt;hr/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;1. 将usb存储格式化成ext3文件系统&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mkfs.ext3 /dev/sdb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;2. 挂载sd卡&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mkdir /mnt/sda1&#xA;mount -t ext3 /dev/sda1 /mnt/sda1&#xA;mkdir /mnt/sda1/packages&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;3. 修改opkg配置文件&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;echo dest usb /mnt/sda1/packages &amp;gt;&amp;gt; /etc/opkg.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;4. opkg更新&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;opkg update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;5. 修改PATH环境变量&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;vim /etc/profile&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;export PATH=$PATH:/mnt/sda1/packages/usr/bin:/mnt/sda1/packages/usr/sbin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;6. 安装软件&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;opkg --dest usb install python&#xA;opkg --dest usb install helloworld.ipk&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>使用openwrt sdk开发ipk</title>
      <link>http://jphome.github.com/blog/2014/03/29/openwrt_sdk.html</link>
      <pubDate>2014-03-29 04:07:24 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;几年前想编译一个helloworld.ipk,由于以下原因当年尝试失败了&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;当年太水(现在还是很湿)&#xA;学校网络太操蛋(ubuntu下借脚本连闪讯,时断时序,编译个固件要纯手工6+H,想想都是泪)&#xA;太jb费时间(一个helloworld整了几天没整出来,灰心了)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr/&gt;&#xA;&#xA;&lt;h4&gt;1. 下载openwrt trunk代码&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;svn co svn://svn.openwrt.org/openwrt/trunk/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;2. 编译openwrt brcm63xx固件,注意勾上sdk&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;make menuconfig&#xA;make V=99&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;3. 使用brcm63xx平台sdk编译ipk&lt;/h4&gt;&#xA;&#xA;&lt;h5&gt;解压 sdk &lt;code&gt;bin/OpenWrt-SDK-xxx.tar.bz2&lt;/code&gt;&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&#xA;tar xvf OpenWrt-SDK-xxx.tar.bz2&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h5&gt;在package路径下建立helloworld工程&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&#xA;    package&#xA;    ├── helloworld&#xA;    │   ├── Makefile&#xA;    │   └── src&#xA;    │       ├── helloworld.c&#xA;    │       └── Makefile&#xA;    └── Makefile&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h5&gt;建立staging_dir链接(涉及到ipkg-build等工具)&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&#xA;cd sdk&#xA;ln -s ../trunk/staging_dir ./staging_dir&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h5&gt;编译&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&#xA;make distclean&#xA;make menuconfig&#xA;make V=99&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&#xA;bin&#xA;├── brcm63xx&#xA;│   └── packages&#xA;│       ├── helloworld_1.0-1_brcm63xx.ipk&#xA;│       ├── Packages&#xA;│       └── Packages.gz&#xA;└── packages&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;hr/&gt;&#xA;&#xA;&lt;h3&gt;代码&lt;/h3&gt;&#xA;&#xA;&lt;h5&gt;package/helloworld/Makefile&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&#xA;include $(TOPDIR)/rules.mk&#xA;include $(INCLUDE_DIR)/package.mk&#xA;&#xA;PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)&#xA;&#xA;PKG_NAME:=helloworld&#xA;# Version: 1.0-1&#xA;PKG_VERSION:=1.0&#xA;PKG_RELEASE:=1&#xA;PKG_MAINTAINER:=JPH &lt;jphome98@gmail.com&gt;&#xA;# PKG_SOURCE_URL:=&#xA;&#xA;define Package/helloworld&#xA;    SECTION:=utils&#xA;    CATEGORY:=Utilities&#xA;    DEFAULT:=y&#xA;    TITLE:=Helloworld -- prints a snarky message&#xA;    # DEPENDS:=+libmath&#xA;endef&#xA;&#xA;define Build/Prepare&#xA;    @echo &#34;############## Build/Prepare&#34;&#xA;    $(Build/Prepare/Default)&#xA;    $(CP) ./src/* $(PKG_BUILD_DIR)  &#xA;endef&#xA;&#xA;define Package/helloworld/install&#xA;    @echo &#34;############## Package/helloworld/install&#34;&#xA;    $(INSTALL_DIR) $(1)/usr/bin&#xA;    $(INSTALL_BIN) $(PKG_BUILD_DIR)/helloworld $(1)/usr/bin&#xA;endef&#xA;&#xA;$(eval $(call BuildPackage,helloworld))&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h5&gt;package/helloworld/src/helloworld.c&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&#xA;#include &lt;stdio.h&gt;&#xA;&#xA;int main(int argc, const char *argv[])&#xA;{&#xA;    printf(&#34;hello world! \n&#34;);&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h5&gt;package/helloworld/src/Makefile&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&#xA;helloworld: helloworld.o&#xA;    $(CC) helloworld.o -o helloworld&#xA;&#xA;helloworld.o: helloworld.c&#xA;    $(CC) -c helloworld.c&#xA;&#xA;clean:&#xA;    rm *.o helloworld&#xA;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>vim按键</title>
      <link>http://jphome.github.com/blog/2013/11/07/shortcut_vim.html</link>
      <pubDate>2013-11-07 11:01:24 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;摘录vim编辑器的常用按键&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://hi.baidu.com/sevkm/item/b6becb46f47b4016896d10ff&#34;&gt;网上参考&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;vim教程&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;:help tutor@cn&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;常用按键&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;d                              ###&amp;lt; 剪切&#xA;y                              ###&amp;lt; 复制&#xA;s                              ###&amp;lt; 剪切并进入insert模式&#xA;p                              ###&amp;lt; 粘帖&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;自动编排格式&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;可视模式选中代码行后按&amp;rsquo;=&amp;rsquo;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;重复操作&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.                               ###&amp;lt; 重复上次的命令&#xA;10dd                            ###&amp;lt; 在按键前加数字(重复次数)&#xA;100iinsert[ESC]                 ###&amp;lt; 插入100个insert&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;缩进代码&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&#xA;&amp;lt;&amp;lt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;移动、跳转&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    k&#xA;h       l&#xA;    j&#xA;w                              ###&amp;lt; 光标往前移动一个词&#xA;b                              ###&amp;lt; 光标往后移动一个词&#xA;0                              ###&amp;lt; 移动光标到当前行首&#xA;^                              ###&amp;lt; 移动光标到当前行的第一个字母位置&#xA;$                              ###&amp;lt; 移动光标到行尾&#xA;)                              ###&amp;lt; 移动光标到下一个句子&#xA;(                              ###&amp;lt; 移动光标到上一个句子&#xA;H                              ###&amp;lt; 移动光标到屏幕上面&#xA;M                              ###&amp;lt; 移动光标到屏幕中间&#xA;L                              ###&amp;lt; 移动光标到屏幕下面&#xA;&#xA;b, w                           ###&amp;lt; 移动到上，下一个词&#xA;gg, G                          ###&amp;lt; 跳到文档开头，结尾&#xA;100G                           ###&amp;lt; 跳到第100行&#xA;&#xA;%                              ###&amp;lt; 跳到括号匹配处&#xA;*                              ###&amp;lt; 匹配当前单词,移动到下一个匹配单词&#xA;#                              ###&amp;lt; 匹配当前单词,移动到上一个匹配单词&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;书签&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ma                             ###&amp;lt; 在当前光标的位置标记一个书签，名字为a(书签名只能是小写字母)&#xA;`a                             ###&amp;lt; 到书签a处&#xA;`.                             ###&amp;lt; 到你上次编辑文件的地方&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;插入&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;i                              ###&amp;lt; 在当前字符的左边插入&#xA;I                              ###&amp;lt; 在当前行首插入&#xA;a                              ###&amp;lt; 在当前字符的右边插入&#xA;A                              ###&amp;lt; 在当前行尾插入&#xA;o                              ###&amp;lt; 在当前行下面插入一个新行&#xA;O                              ###&amp;lt; 在当前行上面插入一个新行&#xA;c{motion}                      ###&amp;lt; 删除motion命令跨过的字符并进入insert模式&#xA;d{motion}                      ###&amp;lt; 删除motion命令跨过的字符&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;退出：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;:q!                            ###&amp;lt; 不保存退出&#xA;:wq                            ###&amp;lt; 保存退出&#xA;ZZ                             ###&amp;lt; 保存并退出&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;undo &amp;amp; redo&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;u                              ###&amp;lt; undo&#xA;&amp;lt;C+r&amp;gt;                          ###&amp;lt; redo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;复制粘帖剪切：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;p                              ###&amp;lt; 粘帖&#xA;]p                             ###&amp;lt; 粘帖 自动调整被粘贴的文本的缩进去适应当前代码的位置&#xA;dd                             ###&amp;lt; 剪切整行&#xA;S                              ###&amp;lt; 剪切整行后进入insert模式&#xA;dw                             ###&amp;lt; 剪切一个单词&#xA;cw                             ###&amp;lt; 剪切一个单词后进入insert模式&#xA;s                              ###&amp;lt; 剪切一个字符&#xA;x                              ###&amp;lt; 剪切一个字符后进入insert模式&#xA;D                              ###&amp;lt; 剪切至行尾&#xA;xp                             ###&amp;lt; 交换两个字符&#xA;ddp                            ###&amp;lt; 交换两行&#xA;yy，Y                          ###&amp;lt; 复制一行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;可视模式即选择模式 配合y（复制），p（粘帖）&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v                              ###&amp;lt; 进入基于字符的可视模式&#xA;V                              ###&amp;lt; 进入基于行的可视模式&#xA;y                              ###&amp;lt; 复制选择的部分&#xA;d                              ###&amp;lt; 剪切选择的部分&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;翻页&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;C+f&amp;gt;, &amp;lt;C+b&amp;gt;                   ###&amp;lt; 向下，上翻页&#xA;&amp;lt;C+d&amp;gt;, &amp;lt;C+u&amp;gt;                   ###&amp;lt; 向下，上半翻页&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;跳到第23行&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;23gg，23G，:23&lt;/h6&gt;&#xA;&#xA;&lt;h3&gt;查找替换&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;C-w&amp;gt; f                        ###&amp;lt; 查找词&#xA;gf                             ###&amp;lt; 查找词&#xA;/text                          ###&amp;lt; 从当前光标处开始搜索字符串text&#xA;?text                          ###&amp;lt; 和上面类似，但是是反方向&#xA;#                              ###&amp;lt; 从光标向后查找整个关键词&#xA;*                              ###&amp;lt; 从光标向前查找整个关键词&#xA;:s/if/else                     ###&amp;lt; 查找替换下一个if&#xA;:%s/if/else                    ###&amp;lt; 查找替换所有if&#xA;:s/if/else/g                   ###&amp;lt; 只对当前行有效&#xA;:1,3 s/if/else/g               ###&amp;lt; 只对1，3行有效&#xA;正则表达区别：词头锚定用\而不是^&#xA;:grep /\&amp;lt;main\&amp;gt;/ src/*.c       ###&amp;lt;&#xA;:vimgrep /\&amp;lt;main\&amp;gt;/ src/*.c    ###&amp;lt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;窗口&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;:split/vsplit                  ###&amp;lt; 分隔一个窗口&#xA;:new/vnew                      ###&amp;lt; 创建一个新的窗口&#xA;:sf xxx                        ###&amp;lt; 在新窗口中打开xxx文件&#xA;:close                         ###&amp;lt; 关闭当前窗口&#xA;:only                          ###&amp;lt; 关闭除当前窗口外所有窗口&#xA;&amp;lt;C-w&amp;gt; v                        ###&amp;lt; 分割&#xA;&amp;lt;C-w&amp;gt; h                        ###&amp;lt; 到左面的窗口&#xA;&amp;lt;C-w&amp;gt; j                        ###&amp;lt; 到下面的窗口&#xA;&amp;lt;C-w&amp;gt; k                        ###&amp;lt; 到上面的窗口&#xA;&amp;lt;C-w&amp;gt; l                        ###&amp;lt; 到右面的窗口&#xA;&amp;lt;C-w&amp;gt; t                        ###&amp;lt; 到顶部的窗口&#xA;&amp;lt;C-w&amp;gt; b                        ###&amp;lt; 到底部的窗口&#xA;&amp;lt;C-w&amp;gt; w                        ###&amp;lt; 切换窗口&#xA;&amp;lt;C-w&amp;gt; &amp;gt;                        ###&amp;lt; 调整窗口大小&#xA;&amp;lt;C-w&amp;gt; &amp;lt;                        ###&amp;lt; 调整窗口大小&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;跳转&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[[ 向前跳到顶格的第一个&amp;quot;{&amp;quot;&#xA;[] 向前跳到顶格的第一个&amp;quot;}&amp;quot;&#xA;][ 向后跳到顶格的第一个&amp;quot;{&amp;quot;&#xA;]] 向后跳到顶格的第一个&amp;quot;}&amp;quot;&#xA;[{ 跳到本代码块(由{}界定)的开头&#xA;[} 跳到本代码块的结尾&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;NERD Commenter注释代码&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;,c Space                       ###&amp;lt; 注释代码&#xA;,c u                           ###&amp;lt; 取消注释&#xA;,c c                           ###&amp;lt; 注释当前行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;vim快捷键图示&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/img/img_shortcut_vim.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>python数据结构</title>
      <link>http://jphome.github.com/blog/2013/11/07/python_data_struct.html</link>
      <pubDate>2013-11-07 10:44:06 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python&#xA;# -*- coding=utf-8 -*-&#xA;#########################################################################&#xA;# File Name: data_struct.py&#xA;# Author: jphome&#xA;# mail: jphome98@gmail.com&#xA;# Created Time: Fri 06 Sep 2013 10:16:51 PM CST&#xA;#########################################################################&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;字符串&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单引号&amp;rsquo;&lt;/li&gt;&#xA;&lt;li&gt;双引号&amp;rdquo;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;三引号&amp;rdquo;&amp;lsquo;或&amp;rdquo;&amp;ldquo;&amp;rdquo;      ###&amp;lt; 可以多行，中间可以使用&amp;rsquo;和&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;h6&gt;转义 &amp;lsquo;What\&amp;rsquo;s &amp;lsquo; &amp;lsquo;your name?&amp;rsquo;     ==&amp;gt;     &amp;lsquo;What\&amp;rsquo;s your name?&amp;rsquo;&lt;/h6&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;name = &#39;Swaroop&#39;;&#xA;if name.startswith(&#39;Swa&#39;):&#xA;    print &#39;xxx&#39;;&#xA;if &#39;a&#39; in name:&#xA;    print &#39;xxx&#39;;&#xA;if name.find(&#39;war&#39;) != -1:&#xA;    print &#39;xxx&#39;;&#xA;delimiter = &#39;_*_&#39;;&#xA;mylist = [&#39;B&#39;, &#39;R&#39;, &#39;I&#39;, &#39;C&#39;];&#xA;print delimiter.join(mylist);   ###&amp;lt; B_*_R_*_I_*_C&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;列表list&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;列表可修改&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;list = [&#39;apple&#39;, &#39;mango&#39;];&#xA;print list;                 ###&amp;lt; 打印 [&#39;apple&#39;, &#39;mango&#39;]&#xA;len(list);                  ###&amp;lt; item个数&#xA;for item in list:           ###&amp;lt; 遍历list&#xA;    print item;&#xA;list.append(&#39;rice&#39;);        ###&amp;lt; 添加item&#xA;list.sort();                ###&amp;lt; 排序list&#xA;olditem = list[0];          ###&amp;lt; 提取item&#xA;del list[0];                ###&amp;lt; 删除item&#xA;&#xA;list.extend(L);             ###&amp;lt; 用链表来扩充链表&#xA;                            ###&amp;lt; 相当于list[len(list):] = L&#xA;list.remove(x);             ###&amp;lt; 移除值为x的元素&#xA;list.pop(3);                ###&amp;lt; &#xA;list.pop();                 ###&amp;lt; 弹出最后一个元素&#xA;list.index(x);              ###&amp;lt; 返回列表中第一个值为x的索引&#xA;list.count(x);              ###&amp;lt; 返回x在列表中出现的次数&#xA;list.reverse();             ###&amp;lt; 列表逆序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;h4&gt;堆栈stack&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;stack = [];&#xA;stack.append(3);&#xA;stack.pop();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;队列queue&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;queue = [];&#xA;queue.append(4);&#xA;queue.pop(0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;列表综合&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;listone = [2, 3, 4];&#xA;listtwo = [2*i for i in listone if i&amp;gt;2];    ###&amp;lt; [6, 8]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;列表切片&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = [0,1,2,3,4,5,6,7,8,9];&#xA;a[2:4];                         ###&amp;lt; a[2]-a[3]&#xA;a[:3];                          ###&amp;lt; a[0]-a[2]&#xA;a[1:6:2];                       ###&amp;lt; a[1] a[3] a[5] 步进为2&#xA;a[i:j:s];                       ###&amp;lt; i默认为-1,j默认为-len(a)-1&#xA;a[::-1];                        ###&amp;lt; a[-1:-len(a)-1:-1] 其实就是列表逆转&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;元组&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;元组不可变,无法修改&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;empty = ();                     ###&amp;lt; 空元组&#xA;singleton = (2, );              ###&amp;lt; 单元素的元组,必须加,&#xA;&#xA;zoo = (&#39;wolf&#39;, &#39;elephant&#39;);&#xA;print zoo;                      ###&amp;lt; 打印 (&#39;wolf&#39;, &#39;elephant&#39;)&#xA;len(zoo);                       ###&amp;lt; item个数&#xA;new_zoo = (zoo, &#39;monkey&#39;);      ###&amp;lt; 转移&#xA;print new_zoo;                  ###&amp;lt; ((&#39;wolf&#39;, &#39;elephant&#39;), &#39;monkey&#39;)&#xA;print new_zoo[0][0];            ###&amp;lt; wolf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# print格式化输出&#xA;age = 22;&#xA;name = &#39;jph&#39;;&#xA;print &#39;%s is %d years old&#39; % (name, age);           ###&amp;lt; 使用元组定制字符串&#xA;print &#39;%s is playing python&#39; % name;                ###&amp;lt; 只需要一个参数时可以不加()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;字典dict&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;键值对,键必须唯一&lt;/h6&gt;&#xA;&#xA;&lt;h6&gt;只能使用不可变的对象(比如字符串)作为键&lt;/h6&gt;&#xA;&#xA;&lt;h6&gt;形式: d = {key1:val1, key2:val2};&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dict = {&#xA;    &#39;j&#39; : &amp;quot;jj&amp;quot;,&#xA;    &#39;p&#39; : &#39;pp&#39;,&#xA;    &#39;h&#39; : &#39;hh&#39;&#xA;};&#xA;dict[&#39;j&#39;] = &#39;jb&#39;;                           ###&amp;lt; 修改item&#xA;del dict[&#39;p&#39;];                              ###&amp;lt; 删除item&#xA;len(dict);                                  ###&amp;lt; item个数&#xA;keys = dict.keys();&#xA;vals = dict.values();&#xA;xxx = dict.get(&#39;a&#39;, &amp;quot;a_default_val&amp;quot;);       ###&amp;lt; 查找&#39;a&#39;对应的val,没有则返回&amp;quot;a_default_val&amp;quot;&#xA;for key, val in dict.items():               ###&amp;lt; 遍历dict&#xA;    print &#39;Contact %s =&amp;gt; %s&#39; % (key, val);&#xA;if &#39;j&#39; in dict:                             ###&amp;lt; 判断是否存在key&#xA;    print &amp;quot;j&#39;s val is %s&amp;quot; % dict[&#39;j&#39;];&#xA;if dict.has_key(&#39;j&#39;):                       ###&amp;lt; 判断是否存在key&#xA;    print &amp;quot;j&#39;s val is %s&amp;quot; % dict[&#39;j&#39;];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;序列&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;列表,元组,字符串都是序列&lt;/h6&gt;&#xA;&#xA;&lt;h6&gt;序列的 索引操作符 &amp;amp; 切片操作符 (index &amp;amp; slicing)&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;list = [&#39;apple&#39;, &#39;mango&#39;, &#39;banana&#39;, &#39;pan&#39;];&#xA;list[0];                    ###&amp;lt; 访问第一个item&#xA;list[-1];                   ###&amp;lt; 访问最后一个item&#xA;list[-2];                   ###&amp;lt; 访问倒数第二个item&#xA;list[1:2];                  ###&amp;lt; 切片 [1]&#xA;list[:3];                   ###&amp;lt; 从头到[2]&#xA;list[2:];                   ###&amp;lt; [2]到尾&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;参考&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;即变量名,指向对象存储的内存&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];&#xA;mylist1 = list;                 ###&amp;lt; 别名&#xA;mylist2 = list[:];              ###&amp;lt; 切片拷贝&#xA;del mylist1[0];                 ###&amp;lt; 会影响到list&#xA;del mylist2[0];                 ###&amp;lt; 不会影响到list&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;集合set&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s = set(&#39;ab&#39;);                  ###&amp;lt; set([&#39;a&#39;, &#39;b&#39;])&#xA;len(s);&#xA;if &#39;a&#39; in s:&#xA;if &#39;c&#39; not in s:&#xA;if s.issubset(ss):              ###&amp;lt; 判断是否s为ss的子集&#xA;if s &amp;lt;= ss:                     ###&amp;lt; 判断是否s为ss的子集&#xA;if ss.issuperset(s):            ###&amp;lt; 判断是否ss为ss的超集&#xA;if ss &amp;gt;= s:                     ###&amp;lt; 判断是否ss为ss的超集&#xA;u = s.union(t);                 ###&amp;lt; 返回并集&#xA;u = s | t;                      ###&amp;lt; 返回并集&#xA;a = s.intersection(t);          ###&amp;lt; 返回交集&#xA;a = s &amp;amp; t;                      ###&amp;lt; 返回交集&#xA;s.difference(t);                ###&amp;lt; 返回s 中有但是 t 中没有的&#xA;s.symmetric_difference(t)       ###&amp;lt; 返回 s 和 t 中不重复的元素&#xA;s ^ t                           ###&amp;lt; 返回 s 和 t 中不重复的元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>vim的相关使用</title>
      <link>http://jphome.github.com/blog/2013/11/06/readme_vim.html</link>
      <pubDate>2013-11-06 10:58:35 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;摘录vim编辑器的使用&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;vim模式&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;nromal&lt;/li&gt;&#xA;&lt;li&gt;visual（选择）&lt;/li&gt;&#xA;&lt;li&gt;insert&lt;/li&gt;&#xA;&lt;li&gt;cmd-line/Ex&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&amp;lsquo;:&amp;lsquo;进入cmd-line模式&lt;/li&gt;&#xA;&lt;li&gt;&amp;lsquo;Q&amp;rsquo;进入Ex模式（多cmd-line模式）&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;常规插件安装方法&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;下载插件包xxx.zip&#xA;解压zip： xxx.txt -&gt; ~/.vim/doc&#xA;xxx.vim -&gt; ~/.vim/plugin&#xA;进~/.vim/doc&#xA;:helptags .                 ###&lt; 把新的xxx.txt加入helptags&#xA;&lt;/pre&gt;&#xA;   &#xA;&#xA;&lt;h3&gt;map命令相关：&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;h4&gt;在设置map时按键名&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;&lt;C-a&gt;       Ctrl+a&#xA;&lt;A-a&gt;       Alt+a&#xA;&lt;C-A-a&gt;     Ctrl+Alt+a&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;map命令前缀&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;默认的map命令影响到normal和visual模式&#xA;nore        表示非递归&#xA;n           表示在普通模式下生效&#xA;v           表示在可视模式下生效&#xA;i           表示在插入模式下生效&#xA;c           表示在命令行模式下生效&#xA;&lt;/pre&gt;&#xA;#### 非递归说明&#xA;&lt;pre&gt;&#xA;:map a b&#xA;:map c a&#xA;对于c等效于&#xA;:map c b&#xA;:noremap c a                   ###&lt; 这种就指定了非递归map&#xA;&lt;/pre&gt;&#xA;#### 清除map&#xA;&lt;pre&gt;&#xA;:unmap c                       ###&lt; 删除映射&#xA;:mapclear                      ###&lt; 直接清除相关模式下的所有映射&#xA;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;taglist.vim中使用的tags生成&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;ctags -R ./src              ###&lt; 生成tags&#xA;ctags -R *&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;保存当前的编辑状态&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;要恢复上次的编辑环境，需要保存session或viminfo&lt;/h6&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;h4&gt;使用Session&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;:mksession [file.vim]       ###&lt; 保存session,默认session文件名为Session.vim&#xA;:mksession!                 ###&lt; 已存在Session.vim的情况下&#xA;:source Session.vim         ###&lt; 恢复vim状态&#xA;vim -S Session.vim          ###&lt; 启动vim时回复session&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;使用viminfo&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&#xA;:wviminfo hsmart.viminfo    ###&lt; 保存viminfo&#xA;:rviminfo hsmart.viminfo    ###&lt; 读入保存的viminfo文件&#xA;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;设置编码格式&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;encoding:       vim内部使用的字符编码方式，包括viｍ的buffer、菜单文本、消息文本等&#xA;fileencoding:   vim中当前编辑的文件的字符编码方式，vim保存文件时也会将文件保存为这种编码方式&#xA;fileencodings:  vim启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将fileencoding设置为最终探测到的字符编码方式。因此最好将unicode编码方式放到这个列表的最前面，将拉丁语系编码方式latin1放到最后面&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;函数&lt;/h3&gt;&#xA;&#xA;&lt;h6&gt;内部调用还是得声明在先&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&#xA;:call test()&#xA;&#xA;func! test()&#xA;endfunc&#xA;&#xA;func test()&#xA;endfunc&#xA;&#xA;function! Test()&#xA;  if&#xA;  else&#xA;  endif&#xA;endfunction&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;插件管理vundle&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle&#xA;:BundleInstall&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;杂项&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&#xA;Ctrl+z/:suspend                ###&lt; 在shell下是挂起vim; gui下是最小化窗口&#xA;:!{command}                    ###&lt; 执行shell命令&#xA;:shell                         ###&lt; 开一个新的shell&#xA;:!time {command}               ###&lt; 跑完显示运行时间&#xA;:r !date                       ###&lt; 将shell执行结果读到正在编辑的文件&#xA;:1,4!sort                      ###&lt; 将几行排序&#xA;:set fileencoding              ###&lt; 查看变量&#xA;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>ubuntu12.04安装PPStream</title>
      <link>http://jphome.github.com/blog/2013/10/27/install_ppstream.html</link>
      <pubDate>2013-10-27 05:58:45 +0800</pubDate>
      <description>&lt;h3&gt;简介:&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;摘自about: PPS网络电视是一款基于P2P技术的流媒体直播软件,能够为宽带用户提供稳定和流畅的视频直播节目。PPS网络电视采用P2P-Streaming技术的流媒体直播&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;1.安装qt4依赖包&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install libqt4-core libqt4-gui libqt4-webkit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;2.&lt;a href=&#34;http://dawndiy.com/archives/52/&#34;&gt;解决Ubuntu12.04下PPStream一直缓冲后跳到下一个问题&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install libjpeg62&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;3.下载安装包&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;wget http://download.ppstream.com/linux/PPStream.deb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;4.安装PPStream&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo dpkg -i PPStream.deb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>cut工具的使用方法</title>
      <link>http://jphome.github.com/blog/2013/10/23/cut.html</link>
      <pubDate>2013-10-23 10:12:30 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;cut作用:用来裁剪数据&#34; href=&#34;#cut作用:用来裁剪数据&#34;&gt;&lt;/a&gt;cut作用:用来裁剪数据&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;参数&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-b      字节(bytes)&#xA;-c      字符(characters)&#xA;-f      域(fields)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;1.-按字节(bytes)&#34; href=&#34;#1.-按字节(bytes)&#34;&gt;&lt;/a&gt;1. 按字节(bytes)&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;一个汉字算3个字节&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date | cut -b 1-4           ###&amp;lt; 取前4B&#xA;date | cut -b 1-4,10        ###&amp;lt; 取前4B和第10个B&#xA;date | cut -b -4            ###&amp;lt; 取1-4B&#xA;date | cut -b 4-            ###&amp;lt; 取第4个B到行尾&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;2.-按字符(characters)&#34; href=&#34;#2.-按字符(characters)&#34;&gt;&lt;/a&gt;2. 按字符(characters)&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;中文字符和空格都算一个字符&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date | cut -c 1-5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;3.-按域(fields)&#34; href=&#34;#3.-按域(fields)&#34;&gt;&lt;/a&gt;3. 按域(fields)&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;-d 制定域分隔符(默认为Tab)&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;-f 制定要剪出哪几个域&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;head -n5 /etc/passwd | cut -d: -f1,3-5      ###&amp;lt; 对passwd文件的前5行进行裁剪&#xA;cut -d&amp;quot; &amp;quot; -f2                               ###&amp;lt; 空格表示&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>readme_python</title>
      <link>http://jphome.github.com/blog/2013/10/16/readme_python.html</link>
      <pubDate>2013-10-16 11:24:31 +0800</pubDate>
      <description>&lt;h3&gt;python模块Package Index:&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://pypi.python.org/pypi&#34;&gt;https://pypi.python.org/pypi&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;从源码安装python模块&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;python setup.py build&#xA;sudo python setup.py install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;python第三方模块管理工具:pip&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;安装:&lt;/h4&gt;&#xA;&#xA;&lt;h5&gt;首先安装setuptools&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;wget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h5&gt;安装pip&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;wget https://pypi.python.org/packages/source/p/pip/pip-1.4.1.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;使用pip:&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;安装第三方模块&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pip install xxx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;升级模块&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pip install --upgrade xxx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;移除模块&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pip uninstall xxx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;&lt;a href=&#34;http://www.lupaworld.com/article-229520-1.html&#34;&gt;性能评估&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;粗粒度的计算时间&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;time python xxx.py&#xA;    real:       实际花费的时间&#xA;    user:       cpu花费在内核外的时间&#xA;    sys:        cpu花费在内核内的时间&#xA;    user+sys: cpu在程序上花费的时间&#xA;如果user+sys&amp;lt;&amp;lt;real,则程序的大部分性能瓶颈在IO等待上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;模块&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;PYTHONPATH包含模块所在路径&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;package&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;包就是模块所在的路径&lt;br \&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;比如有两个模块 color.py shape.py&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;PYTHONPATH=.:$(PYTHONPATH)&#xA;./draw/__init__.py&#xA;./draw/color.py&#xA;./draw/shape.py&#xA;&#xA;import draw;            ###&amp;lt; __init__.py生效,coloe/shape不可用&#xA;import draw.color;      ###&amp;lt; color可用,但得用全名:draw.color&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>git使用相关</title>
      <link>http://jphome.github.com/blog/2013/10/16/readme_git.html</link>
      <pubDate>2013-10-16 09:37:03 +0800</pubDate>
      <description>&lt;h3&gt;1. 安装&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install git git-core&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;2. 配置 设置你的名字和email(提交commit时的签名)&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;jphome&amp;quot;&#xA;git config --global user.email &amp;quot;jphome98@gmail.com&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;执行了上面的命令后,会在你的主目录(home directory)建立一个叫 ~/.gitconfig 的文件&lt;/h4&gt;&#xA;&#xA;&lt;h5&gt;内容一般像下面这样:&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[user]&#xA;    name = jphome&#xA;    email = jphome98@gmail.com&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注:这样的设置是全局设置,会影响此用户建立的每个项目.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3. git命令&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/jphome/hSmart.git&#xA;git add *&#xA;git commit&#xA;git remote add origin https://github.com/jphome/hSmart.git&#xA;git push -u origin master&#xA;&#xA;&#xA;本地编辑前&#xA;git pull&#xA;如果有冲突就会提示 处理冲突&#xA;然后 git ci -a&#xA;然后 git push 同步github上的数据&#xA;&#xA;&#xA;编辑完了后&#xA;git ci -a&#xA;git push&#xA;&#xA;&#xA;当本地与远程冲突时&#xA;git fetch origin            ###&amp;lt; 获取冲突&#xA;git merge origin            ###&amp;lt; 如果merge失败 手动编辑修改&#xA;git ci -a&#xA;git add *&#xA;git push&#xA;&#xA;&#xA;git init&#xA;git add file1 file2 file3   ###&amp;lt; 将更新的内容（修改 &amp;amp; 新增）添加到索引中&#xA;&#xA;git commit -a               ###&amp;lt; 自动把所有内容被修改的文件(不包括新创建的文件)都添加到索引中,并且同时把它们提交&#xA;git diff --cached           ###&amp;lt; 查看哪些文件将被提交（commit）&#xA;git diff                    ###&amp;lt; 查看当前你所有已做的但没有加入到索引里的修改&#xA;git diff HEAD               ###&amp;lt; 显示你工作目录与上次提交时之间的所有差别&#xA;git commit                  ###&amp;lt; 提交到本地&#xA;&#xA;&#xA;git push                    ###&amp;lt; 推到网上仓库&#xA;git pull                    ###&amp;lt; 从远程仓库down更新 = git fetch + git merge&#xA;                            ###&amp;lt; 当本地与远程都编辑了 git pull就会失败&#xA;&#xA;&#xA;git branch experimental     ###&amp;lt; 新建分支&#xA;git branch                  ###&amp;lt; 查看所有分支（*为当前所处分支）&#xA;git checkout experimental   ###&amp;lt; 切换分支&#xA;git merge experimental      ###&amp;lt; 合并分支experimental到当前分支&#xA;git branch -d experimental  ###&amp;lt; 删除分支experimental&#xA;gitk                        ###&amp;lt; 图形界面显示项目历史&#xA;git reset --hard HEAD       ###&amp;lt; 回到合并之前的状态&#xA;git diff master..test       ###&amp;lt; 显示两个分支间的差异&#xA;git diff master...test      ###&amp;lt; 显示‘master’,‘test’的共有 父分支和&#39;test&#39;分支之间的差异&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派USB无线网卡配置</title>
      <link>http://jphome.github.com/blog/2013/10/15/config_wifi.html</link>
      <pubDate>2013-10-15 09:03:24 +0800</pubDate>
      <description>&lt;h3&gt;说明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;配置树莓派wifi，开机连上路由器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参考: &lt;a href=&#34;http://www.2fz1.com/?p=353&#34;&gt;http://www.2fz1.com/?p=353&lt;/a&gt;&#xA;&lt;hr/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;购置无线网卡&#xA;手头本来有一个RT3070,可是怎么都搞不定&#xA;后淘了个&lt;a href=&#34;http://detail.tmall.com/item.htm?id=14795585956&#34;&gt;EDUP的EP-N8508GS&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;1.查看插入的无线网卡驱动有没有加载&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lsusb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;我的显示如下无线网卡信息&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Bus 001 Device 004: ID 0bda:8176 Realtek Semiconductor Corp. RTL8188CUS 802.11n WLAN Adapter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;2.配置网卡配置文件&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /etc/network&#xA;cp interfaces interfaces.bak&#xA;sudo vi interfaces &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;内容如下&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;auto lo&#xA;iface lo inet loopback&#xA;iface eth0 inet dhcp&#xA;&#xA;auto wlan0&#xA;allow-hotplug wlan0&#xA;iface wlan0 inet dhcp&#xA;wpa-ssid &amp;quot;SSID&amp;quot;&#xA;wpa-psk &amp;quot;PASSWORD&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;3.配置路由器为树莓派静态分配ip&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;br \&gt;&lt;/p&gt;&#xA;&#xA;&lt;h5&gt;存在的问题: 网卡插入后设备自动重启,略讨厌,不过总归有网上了&lt;/h5&gt;&#xA;</description>
    </item>
    <item>
      <title>配置blog环境</title>
      <link>http://jphome.github.com/blog/2013/10/14/config_blog.html</link>
      <pubDate>2013-10-14 09:54:42 +0800</pubDate>
      <description>&lt;h3&gt;配置vim(~/.vimrc)&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;自动添加mkd文件头&lt;/h4&gt;&#xA;&#xA;&lt;h5&gt;1.新建文件(vim xxx.md)&lt;/h5&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;autocmd BufNewFile *.md exec &amp;quot;:call SetTitle()&amp;quot;&#xA;func! SetTitle()&#xA;    if &amp;amp;filetype == &#39;mkd&#39;&#xA;        call setline(1,&amp;quot;---&amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;), &amp;quot;title: &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+1, &amp;quot;date: &#39;&amp;quot;.strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;).&amp;quot;&#39;&amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+2, &amp;quot;permalink: &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+3, &amp;quot;description: &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+4, &amp;quot;categories: &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+5, &amp;quot;- &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+6, &amp;quot;- &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+7, &amp;quot;&amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+8, &amp;quot;tags: &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+9, &amp;quot;- &amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+10, &amp;quot;---&amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+11, &amp;quot;&amp;quot;)&#xA;        call append(line(&amp;quot;.&amp;quot;)+12, &amp;quot;&amp;quot;)&#xA;    endif&#xA;endfunc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;2.更新已有文件(xxx -&amp;gt; xxx.md)&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;map &amp;lt;F5&amp;gt; :call AddAutoHead()&amp;lt;CR&amp;gt;&#xA;func! AddAutoHead()&#xA;    exec &amp;quot;w&amp;quot;&#xA;    if &amp;amp;filetype == &#39;mkd&#39;&#xA;        call append(0, &amp;quot;---&amp;quot;)&#xA;        call append(1, &amp;quot;title: &amp;quot;)&#xA;        call append(2, &amp;quot;date: &#39;&amp;quot;.strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;).&amp;quot;&#39;&amp;quot;)&#xA;        call append(3, &amp;quot;permalink: &amp;quot;)&#xA;        call append(4, &amp;quot;description: &amp;quot;)&#xA;        call append(5, &amp;quot;categories: &amp;quot;)&#xA;        call append(6, &amp;quot;- &amp;quot;)&#xA;        call append(7, &amp;quot;- &amp;quot;)&#xA;        call append(8, &amp;quot;&amp;quot;)&#xA;        call append(9, &amp;quot;tags:&amp;quot;)&#xA;        call append(10, &amp;quot;- &amp;quot;)&#xA;        call append(11, &amp;quot;---&amp;quot;)&#xA;        call append(12, &amp;quot;&amp;quot;)&#xA;        call append(13, &amp;quot;&amp;quot;)&#xA;        endif&#xA;endfunc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;自动更新当前编辑文件至blog(本地) [按Ctrl+F5]&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;quot; 需要事先设置blog_root环境变量&#xA;map &amp;lt;C-F5&amp;gt; :call RunXxx()&amp;lt;CR&amp;gt;&#xA;func! RunXxx()&#xA;    exec &amp;quot;w&amp;quot;&#xA;    if &amp;amp;filetype == &#39;mkd&#39;&#xA;        exec &amp;quot;!cp % $blog_root/posts&amp;quot;&#xA;        exec &amp;quot;!cd $blog_root &amp;amp;&amp;amp; gor compile&amp;quot;&#xA;    endif&#xA;endfunc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>学习markdown语言语法</title>
      <link>http://jphome.github.com/blog/2013/10/13/syntax_markdown.html</link>
      <pubDate>2013-10-13 10:45:44 +0800</pubDate>
      <description>&lt;p&gt;From: &lt;a href=&#34;http://wowubuntu.com/markdown/basic.html&#34;&gt;basic&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;回车&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;br /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;标题(两种语法)&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;Setext&lt;/em&gt;: 底线形式 === 或 &amp;mdash;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;atx&lt;/em&gt;: 在行首插入 1 到 6 个 #&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;修辞和强调&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;*emphasized*        ###&amp;lt; 斜体&#xA;_emphasized_        ###&amp;lt; 斜体&#xA;**strong**          ###&amp;lt; strong&#xA;__strong__          ###&amp;lt; strong&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;行内代码&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用反引号&#39;`&#39;包裹起来&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;列表(* + - num)&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;* 1                 ###&amp;lt; 无序列表&#xA;* 2&#xA;* 3&#xA;&#xA;+ 1                 ###&amp;lt; 无序列表&#xA;+ 2&#xA;+ 3&#xA;&#xA;- 1                 ###&amp;lt; 无序列表&#xA;- 2&#xA;- 3&#xA;&#xA;1. a                ###&amp;lt; 有序列表&#xA;2. a&#xA;3. a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;文字链接&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[xxx&#39;s blog](http://xxx.com &amp;quot;title&amp;quot;)    ###&amp;lt; 行内形式&#xA;&#xA;[xxx&#39;s blog][id]                        ###&amp;lt; 参考形式&#xA;[id]: http://url_1.com&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;图片链接&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;(打算在blog中使用yunio网盘的图片外链,尚未成功 - - 貌似不被支持了)&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;![alt text](/path/to/img.jpg &amp;quot;title&amp;quot;)   ###&amp;lt; 行内形式&#xA;&#xA;![alt text][id]                         ###&amp;lt; 参考形式&#xA;[id]: /path/to/img.jpg &amp;quot;title&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&#xA;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;测试几张外链的图片&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://pic.baike.soso.com/p/20130304/bki-20130304161213-1881616484.jpg&#34; alt=&#34;yunio&#34; title=&#34;yunio&#34; /&gt;&#xA; Yunio网盘,竟然升级到1T了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/003/monkey/1.gif&#34; alt=&#34;hehe&#34; /&gt;&#xA;&#xA;&lt;img src=&#34;http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/003/monkey/2.gif&#34; alt=&#34;hehe&#34; /&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>gor搭建个人博客(github静态博客)</title>
      <link>http://jphome.github.com/blog/2013/10/13/readme_blog_init.html</link>
      <pubDate>2013-10-13 10:20:45 +0800</pubDate>
      <description>&lt;h3&gt;简介:&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;以前习惯把积累的东西用readme文件的形式存在本地,方便查阅&#xA;现在打算整理成静态blog的形式,简单方便,走到哪儿都可以查阅&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;静态博客 [&lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;gor&lt;/a&gt; &amp;ndash; Golang编写]&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;安装gor&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/wendal/gor&#xA;go install github.com/wendal/gor/gor&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;新建站点 生成jphome98.com文件夹&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor new jphome98.com&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;新建单篇博客&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd jphome98.com&#xA;gor post &amp;quot;readme&amp;quot;           ###&amp;lt; 生成博客页 posts/readme.md&#xA;                            ###&amp;lt; 编辑 readme.md&#xA;                            ###&amp;lt; 当然也可以编辑好xxx.md直接放到 posts下&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;编译&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile                 ###&amp;lt; 生成的资源放在compiled文件夹&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;本地预览&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor http&#xA;浏览器输入localhost:8080&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;部署到github上   || e.g: &lt;a href=&#34;https://github.com/hugozhu/blog&#34;&gt;hugozhu&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在github上新建repo &amp;quot;jphome.github.com&amp;quot;&#xA;将compiled提交到此repo&#xA;即可通过http://jphome.github.com访问&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;基本配置&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;打开站点根目录下的site.yml文件&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 填入title, 作者等信息&#xA;2. 填入邮箱等信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开站点根目录下的config.yml文件&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 设置production_url为你的网站地址, 例如 http://wendal.net 最后面不需要加入/ 生成rss.xml等文件时会用到&#xA;2. summary_lines 首页的文章摘要的长度,按你喜欢的呗&#xA;3. latest 首页显示多少文章&#xA;4. imgs 部分为自动插入 &amp;lt;img&amp;gt; 相关的配置&#xA;    imgtag：要插入的  标签的基本格式，%s 部分会被自动替换为 urlperfix/post_name/img_file_name 的格式&#xA;    urlperfix： 图片地址前缀&#xA;    localdir：图片文件在博客内的本地存放目录&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开widgets目录, 可以看到基本的挂件,里面有config.yml配置文件&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. analytics 暂时只支持google analytics, 填入tracking_id&#xA;2. comments 暂时只支持disqus, 请填入short_name&#xA;3. google_prettify 代码高亮,一般不修改&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>